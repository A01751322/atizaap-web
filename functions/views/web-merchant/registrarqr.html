<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/flowbite@3.1.2/dist/flowbite.min.css" rel="stylesheet"/>
  </head>
  <body class="pt-14">
  <!--Placeholder de navbar -->
    <div id="navbar-placeholder"
      data-partial="/partials/navbarmerchant.html"
      data-content-id="page-content"
      data-slot-selector="#content-slot"
      data-fallback-selector=".border-dashed.rounded-lg"></div> 
  <!-- Script Placeholder de navbar y tokenización -->
    <script>
      document.addEventListener('DOMContentLoaded', async () => {
        const mount = document.getElementById('navbar-placeholder');
        try {
        // cache-buster para evitar versiones viejas en escritorio
        const res = await fetch('/partials/navbarmerchant.html?v=' + Date.now());
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const html = await res.text();
        mount.innerHTML = html;

        // Mover el contenido de la página dentro del recuadro con líneas
        const content = document.getElementById('page-content');
        let slot = mount.querySelector('#content-slot');

        // Fallback: si el slot no existe, lo creamos dentro del primer recuadro punteado
        if (!slot) {
          const dashed = mount.querySelector('.border-dashed.rounded-lg');
          if (dashed) {
          slot = document.createElement('div');
          slot.id = 'content-slot';
          dashed.appendChild(slot);
          }
        }

        if (slot && content) {
            slot.appendChild(content);
        } else {
            console.warn('No se encontró content-slot ni contenido para mover');
        }

        // Cargar tabs y activar la pestaña correspondiente (forzar por data-active-tab)
        const tabsMount = document.getElementById('tabs-placeholder');
        if (tabsMount) {
          const tRes = await fetch('/partials/tabsregistrar.html?v=' + Date.now());
          if (!tRes.ok) throw new Error('HTTP ' + tRes.status);
          tabsMount.innerHTML = await tRes.text();

          const mano = tabsMount.querySelector('[data-tab="mano"]');
          const qr  = tabsMount.querySelector('[data-tab="qr"]');

          const reset = () => {
            [mano, qr].forEach(a => {
            if (!a) return;
            a.classList.remove('text-blue-600','border-blue-600','active','dark:text-blue-500','dark:border-blue-500','border-b-2');
            a.classList.add('border-transparent');
            a.removeAttribute('aria-current');
            });
          };
          const setActive = (el) => {
            if (!el) return;
            el.classList.add('text-blue-600','border-b-2','border-blue-600','active','dark:text-blue-500','dark:border-blue-500');
            el.classList.remove('border-transparent');
            el.setAttribute('aria-current','page');
          };
          const setInactive = (el) => {
            if (!el) return;
            el.classList.remove('text-blue-600','border-blue-600','active','dark:text-blue-500','dark:border-blue-500','border-b-2');
            el.classList.add('border-transparent');
            el.removeAttribute('aria-current');
          };

          const desired = document.getElementById('page-content')?.dataset.activeTab || 'mano';
          const reapply = () => {
            reset();
            if (desired === 'qr') {
            setActive(qr);
            setInactive(mano);
            } else {
            setActive(mano);
            setInactive(qr);
            }
          };

            reapply();
            requestAnimationFrame(reapply);
          }


          // Re‑inicializa Flowbite para los elementos añadidos dinámicamente
          if (window.initFlowbite) window.initFlowbite();
          } catch (err) {
          console.error('Error al cargar la barra de navegación:', err);
          mount.innerHTML = '<div class="fixed w-16 h-screen bg-gray-800 text-white p-4">Error al cargar</div>';
          }
        });
    </script>
      <main id="page-content" data-active-tab="qr">
        <h1 class="text-3xl font-bold">Registro QR</h1>
        <div id="tabs-placeholder" class="mb-4"></div>
        <section id="qr-section" class="space-y-4">
          <div class="flex items-center gap-3">
            <label for="camera-select" class="text-sm font-medium">Cámara</label>
            <select id="camera-select" class="border rounded px-3 py-2 text-sm"></select>

            <button id="start-scan" class="px-4 py-2 text-white bg-blue-600 rounded hover:bg-blue-700 text-sm">Iniciar</button>
            <button id="stop-scan" class="px-4 py-2 text-white bg-gray-600 rounded hover:bg-gray-700 text-sm" disabled>Detener</button>
            <label class="px-4 py-2 text-white bg-gray-800 rounded hover:bg-gray-900 text-sm cursor-pointer">
              Tomar foto
              <input id="qr-file" type="file" accept="image/*" capture="environment" class="hidden">
            </label>
          </div>

          <div class="relative w-full max-w-md aspect-[3/4] bg-gray-900 rounded overflow-hidden">
            <video id="qr-video" class="w-full h-full object-cover" autoplay muted playsinline></video>

            <!-- Overlay de guía -->
            <div class="pointer-events-none absolute inset-0 grid place-items-center">
              <div class="w-3/4 aspect-square border-2 border-green-400/80 rounded-md"></div>
            </div>
          </div>

          <div class="space-y-1">
            <p class="text-sm text-gray-600">Resultado</p>
            <input id="qr-result" type="text" class="w-full border rounded px-3 py-2" placeholder="Aún no hay lectura..." readonly>
            <div class="text-xs text-gray-500" id="qr-hints"></div>
          </div>
        </section>
      </main>
      <script defer src="/static/merchant/navbar.js"></script>
  </body>
  
  <script defer src="https://cdn.jsdelivr.net/npm/flowbite@3.1.2/dist/flowbite.min.js"></script>
  <script src="https://unpkg.com/@zxing/library@0.20.0"></script>
  <script>
    (function () {
      // Aviso si no es contexto seguro (HTTPS o localhost)
      function warn(msg) {
        try { console.warn(msg); } catch(_) {}
        const hints = document.getElementById('qr-hints');
        if (hints) hints.textContent = msg;
      }
      const insecure = location.protocol !== 'https:' && location.hostname !== 'localhost';
      if (insecure) {
        warn('Necesitas abrir esta página con HTTPS (o localhost) para usar la cámara en iOS/Android.');
      }

      // Feature detection y shim para navegadores viejos / in-app browsers
      if (!navigator.mediaDevices) navigator.mediaDevices = {};
      if (!navigator.mediaDevices.getUserMedia) {
        const legacy = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
        if (legacy) {
          navigator.mediaDevices.getUserMedia = function (constraints) {
            return new Promise((resolve, reject) => legacy.call(navigator, constraints, resolve, reject));
          };
        }
      }
      const hasGUM = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);

      // Elementos
      const video = document.getElementById('qr-video');
      const select = document.getElementById('camera-select');
      const startBtn = document.getElementById('start-scan');
      const stopBtn  = document.getElementById('stop-scan');
      const resultEl = document.getElementById('qr-result');
      const hintsEl  = document.getElementById('qr-hints');
      const fileInput = document.getElementById('qr-file');

      if (!video || !select || !startBtn || !stopBtn) return;

      const codeReader = new ZXing.BrowserQRCodeReader();
      let currentDeviceId = null;
      let running = false;

      // Listar cámaras
      async function populateCameras() {
        try {
          const devices = await codeReader.listVideoInputDevices();
          select.innerHTML = '';
          devices.forEach((d, idx) => {
            const opt = document.createElement('option');
            opt.value = d.deviceId;
            opt.textContent = d.label || 'Cámara ' + (idx + 1);
            select.appendChild(opt);
          });
          // Elegir la trasera si la encontramos en el label
          const back = [...select.options].find(o =>
            /back|rear|environment/i.test(o.textContent)
          );
          if (back) {
            select.value = back.value;
          } else if (select.options.length > 0) {
            select.selectedIndex = 0;
          }
        } catch (e) {
          hintsEl.textContent = 'No se pudieron listar cámaras. Da permiso de cámara y recarga.';
          console.error(e);
        }
      }

      // Iniciar escaneo
      async function start() {
        if (running) return;
        if (!hasGUM) {
          hintsEl.textContent = 'Este navegador no permite cámara (¿falta HTTPS o es un navegador embebido?).';
          startBtn.disabled = false;
          stopBtn.disabled = true;
          return;
        }
        startBtn.disabled = true;
        stopBtn.disabled = false;
        select.disabled = true;
        resultEl.value = '';
        hintsEl.textContent = 'Apunta al QR…';

        currentDeviceId = select.value || undefined;

        try {
          const constraints = currentDeviceId
            ? { video: { deviceId: { exact: currentDeviceId } } }
            : { video: { facingMode: { ideal: 'environment' } } };
          
          await codeReader.decodeFromConstraints(
            constraints,
            video,
            (result, err, controls) => {
              if (result) {
                resultEl.value = result.getText();
                hintsEl.textContent = 'QR detectado ✓';
                // Detener tras primera lectura (opcional)
                stop(controls);
                try { navigator.vibrate && navigator.vibrate(80); } catch (_) {}
              }
              // Ignoramos errores de decodificación intermitentes
            }
          );
          running = true;
        } catch (e) {
          console.error(e);
          hintsEl.textContent = 'Error al iniciar la cámara: ' + (e.message || e);
          startBtn.disabled = false;
          stopBtn.disabled = true;
          select.disabled = false;
        }
      }

      // Detener escaneo
      function stop(controls) {
        try {
          (controls || codeReader).reset();
        } catch (_) {}
        running = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        select.disabled = false;
        hintsEl.textContent = 'Escaneo detenido.';
      }

      // Eventos UI
      startBtn.addEventListener('click', start);
      stopBtn.addEventListener('click', () => stop());

      if (fileInput) {
        fileInput.addEventListener('change', async (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          hintsEl.textContent = 'Procesando imagen…';
          try {
            const url = URL.createObjectURL(file);
            // Usamos un elemento <img> para asegurar decodificación cross-platform
            const img = new Image();
            img.onload = async () => {
              try {
                const res = await codeReader.decodeFromImageElement(img);
                resultEl.value = res.getText();
                hintsEl.textContent = 'QR detectado desde foto ✓';
                try { navigator.vibrate && navigator.vibrate(80); } catch(_) {}
              } catch (err) {
                console.error(err);
                hintsEl.textContent = 'No se pudo leer el QR de la imagen.';
              } finally {
                URL.revokeObjectURL(url);
              }
            };
            img.onerror = () => {
              hintsEl.textContent = 'Imagen inválida.';
              URL.revokeObjectURL(url);
            };
            img.src = url;
          } catch (err) {
            console.error(err);
            hintsEl.textContent = 'Error procesando la imagen.';
          } finally {
            // resetea el input para permitir re-subir la misma imagen si se desea
            e.target.value = '';
          }
        });
      }

      // Preparar lista de cámaras (algunos navegadores requieren permiso primero)
      (async () => {
        if (!hasGUM) {
          warn('La API de cámara no está disponible aquí. Abre en Safari/Chrome y con HTTPS.');
          await populateCameras().catch(() => {});
          return;
        }
        try {
          const prep = await navigator.mediaDevices.getUserMedia({ video: true });
          prep.getTracks().forEach(t => t.stop());
        } catch (_) {
          // Puede fallar por permisos; seguimos
        } finally {
          await populateCameras().catch(() => {});
        }
      })();
    })();
  </script>
</html>